import 'package:bloc_test/bloc_test.dart';
import 'package:flutter/services.dart';
import 'package:flutter_stripe/flutter_stripe.dart'; // For StripeException
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:shop_trendy/features/cart/domain/entities/cart_item.dart';
import 'package:shop_trendy/features/cart/domain/usecases/add_to_cart_usecase.dart';
import 'package:shop_trendy/features/cart/domain/usecases/clear_cart_usecase.dart';
import 'package:shop_trendy/features/cart/domain/usecases/get_cart_items_usecase.dart';
import 'package:shop_trendy/features/cart/domain/usecases/remove_from_cart_usecase.dart';
import 'package:shop_trendy/features/cart/domain/usecases/update_cart_item_quantity_usecase.dart';
import 'package:shop_trendy/features/cart/presentation/cubit/cart_cubit.dart';
import 'package:shop_trendy/features/payment/domain/usecases/create_payment_intent_usecase.dart';
import 'package:shop_trendy/features/product/domain/entities/product.dart';

import 'cart_cubit_test.mocks.dart'; // Generated by build_runner


@GenerateMocks([
  AddToCartUseCase,
  RemoveFromCartUseCase,
  UpdateCartItemQuantityUseCase,
  GetCartItemsUseCase,
  ClearCartUseCase,
  CreatePaymentIntentUseCase,
])
void main() {
  late CartCubit cartCubit;
  late MockAddToCartUseCase mockAddToCart;
  late MockRemoveFromCartUseCase mockRemoveFromCart;
  late MockUpdateCartItemQuantityUseCase mockUpdateCartItemQuantity;
  late MockGetCartItemsUseCase mockGetCartItems;
  late MockClearCartUseCase mockClearCart;
  late MockCreatePaymentIntentUseCase mockCreatePaymentIntent;



  final tProduct = Product(
    id: 1,
    title: 'Test Product',
    price: 100.0,
    description: 'Description',
    category: 'electronics',
    image: 'image.jpg',
    rating: Rating(rate: 4.5, count: 100),
  );
  final tCartItem = CartItem(id: '1', product: tProduct, quantity: 1);
  final tCartItemDifferent = CartItem(id: '2', product: tProduct.copyWith(id: 2, title: 'Another Product'), quantity: 1);

  setUp(() {
    mockAddToCart = MockAddToCartUseCase();
    mockRemoveFromCart = MockRemoveFromCartUseCase();
    mockUpdateCartItemQuantity = MockUpdateCartItemQuantityUseCase();
    mockGetCartItems = MockGetCartItemsUseCase();
    mockClearCart = MockClearCartUseCase();
    mockCreatePaymentIntent = MockCreatePaymentIntentUseCase();


    TestWidgetsFlutterBinding.ensureInitialized(); // Required for Stripe mocks

    // Set a dummy publishable key to satisfy internal Stripe validation
    Stripe.publishableKey = 'pk_test_dummy_key_for_tests';

    // Mock the MethodChannel for flutter_stripe
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
      const MethodChannel('flutter_stripe'),
          (MethodCall methodCall) async {
        // Handle init method call
        if (methodCall.method == 'init') {
          return null; // Simulate successful initialization
        }
        // Handle initPaymentSheet method call
        if (methodCall.method == 'initPaymentSheet') {
          return null; // Simulate successful payment sheet initialization
        }
        // Handle presentPaymentSheet method call
        if (methodCall.method == 'presentPaymentSheet') {
          return null; // Simulate successful payment sheet presentation
        }
        return null; // For unhandled method calls
      },
    );

    cartCubit = CartCubit(
      mockAddToCart,
      mockRemoveFromCart,
      mockUpdateCartItemQuantity,
      mockGetCartItems,
      mockClearCart,
      mockCreatePaymentIntent,
    );
  });

  tearDown(() {
    cartCubit.close();
    // Clear the mock method call handler after each test
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
      const MethodChannel('flutter_stripe'),
      null,
    );
  });

  group('CartCubit', () {
    test('initial state is CartInitial', () {
      expect(cartCubit.state, CartInitial());
    });

    blocTest<CartCubit, CartState>(
      'emits [CartLoading, CartLoaded] when loadCartItems is successful',
      build: () {
        when(mockGetCartItems()).thenAnswer((_) async => [tCartItem]);
        return cartCubit;
      },
      act: (cubit) => cubit.loadCartItems(),
      expect: () => [
        CartLoading(),
        CartLoaded(items: [tCartItem]),
      ],
      verify: (_) {
        verify(mockGetCartItems()).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'emits [CartLoading, CartError] when loadCartItems fails',
      build: () {
        when(mockGetCartItems()).thenThrow(Exception('Failed to load'));
        return cartCubit;
      },
      act: (cubit) => cubit.loadCartItems(),
      expect: () => [
        CartLoading(),
        const CartError('Exception: Failed to load'),
      ],
    );

    blocTest<CartCubit, CartState>(
      'adds new item to cart when addItemToCart is called and item is not existing',
      build: () {
        when(mockAddToCart(tCartItem)).thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => const CartLoaded(items: []),
      act: (cubit) => cubit.addItemToCart(tCartItem),
      expect: () => [
        CartLoaded(items: [tCartItem]),
      ],
      verify: (_) {
        verify(mockAddToCart(tCartItem)).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'updates quantity if item exists when addItemToCart is called',
      build: () {
        when(mockUpdateCartItemQuantity(tCartItem.id, 2))
            .thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => CartLoaded(items: [tCartItem]),
      act: (cubit) => cubit.addItemToCart(tCartItem.copyWith(quantity: 1)),
      expect: () => [
        CartLoaded(items: [tCartItem.copyWith(quantity: 2)]),
      ],
      verify: (_) {
        verify(mockUpdateCartItemQuantity(tCartItem.id, 2)).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'removes item from cart when removeItemFromCart is called',
      build: () {
        when(mockRemoveFromCart(tCartItem.id))
            .thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => CartLoaded(items: [tCartItem]),
      act: (cubit) => cubit.removeItemFromCart(tCartItem.id),
      expect: () => [
        const CartLoaded(items: []),
      ],
      verify: (_) {
        verify(mockRemoveFromCart(tCartItem.id)).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'increments quantity when incrementQuantity is called',
      build: () {
        when(mockUpdateCartItemQuantity(tCartItem.id, 2))
            .thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => CartLoaded(items: [tCartItem]),
      act: (cubit) => cubit.incrementQuantity(tCartItem.id),
      expect: () => [
        CartLoaded(items: [tCartItem.copyWith(quantity: 2)]),
      ],
      verify: (_) {
        verify(mockUpdateCartItemQuantity(tCartItem.id, 2)).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'decrements quantity when decrementQuantity is called',
      build: () {
        when(mockUpdateCartItemQuantity(tCartItem.id, 0)) // quantity becomes 0, so remove
            .thenAnswer((_) async => Future.value());
        when(mockRemoveFromCart(tCartItem.id))
            .thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => CartLoaded(items: [tCartItem.copyWith(quantity: 1)]),
      act: (cubit) => cubit.decrementQuantity(tCartItem.id),
      expect: () => [
        const CartLoaded(items: []),
      ],
      verify: (_) {
        verify(mockRemoveFromCart(tCartItem.id)).called(1);
      },
    );

    blocTest<CartCubit, CartState>(
      'clears all items when clearAllItems is called',
      build: () {
        when(mockClearCart()).thenAnswer((_) async => Future.value());
        return cartCubit;
      },
      seed: () => CartLoaded(items: [tCartItem, tCartItemDifferent]),
      act: (cubit) => cubit.clearAllItems(),
      expect: () => [
        CartLoading(),
        const CartLoaded(items: []),
      ],
      verify: (_) {
        verify(mockClearCart()).called(1);
      },
    );
    test('cartTotalPrice returns correct total', () {
      final item1 = CartItem(id: 'a', product: tProduct.copyWith(price: 50.0), quantity: 2);
      final item2 = CartItem(id: 'b', product: tProduct.copyWith(id: 3, price: 25.0), quantity: 3);
      cartCubit.emit(CartLoaded(items: [item1, item2]));
      // 50 * 2 + 25 * 3 = 100 + 75 = 175
      expect(cartCubit.cartTotalPrice, 175.0);
    });

    test('totalCartItemsCount returns correct total quantity', () {
      final item1 = CartItem(id: 'a', product: tProduct.copyWith(price: 50.0), quantity: 2);
      final item2 = CartItem(id: 'b', product: tProduct.copyWith(id: 3, price: 25.0), quantity: 3);
      cartCubit.emit(CartLoaded(items: [item1, item2]));
      expect(cartCubit.totalCartItemsCount, 5);
    });
  });
}
