import 'package:bloc_test/bloc_test.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:shop_trendy/features/product/domain/entities/product.dart';
import 'package:shop_trendy/features/product/domain/usecases/get_product_details_usecase.dart';
import 'package:shop_trendy/features/product/domain/usecases/get_products_by_category_usecase.dart';
import 'package:shop_trendy/features/product/domain/usecases/get_products_usecase.dart';
import 'package:shop_trendy/features/product/presentation/cubit/product_cubit.dart';

import 'product_cubit_test.mocks.dart'; // Generated by build_runner

@GenerateMocks([
  GetProductsUseCase,
  GetProductDetailsUseCase ,
  GetProductsByCategoryUseCase,
])
void main() {
  late ProductCubit productCubit;
  late MockGetProductsUseCase mockFetchAllProducts;
  late MockGetProductDetailsUseCase mockFetchProductDetails;
  late MockGetProductsByCategoryUseCase mockFetchProductsByCategory;

  final tProduct = Product(
    id: 1,
    title: 'Test Product',
    price: 100.0,
    description: 'Description',
    category: 'electronics',
    image: 'image.jpg',
    rating: Rating(rate: 4.5, count: 100),
  );
  final tProduct2 = Product(
    id: 2,
    title: 'Test Product 2',
    price: 200.0,
    description: 'Description 2',
    category: 'electronics',
    image: 'image2.jpg',
    rating: Rating(rate: 4.0, count: 50),
  );

  // test data for pagination
  final List<Product> tProductsPage1 = List.generate(10, (index) => Product(
    id: index + 1,
    title: 'Product ${index + 1}',
    price: 10.0 + index,
    description: 'Description for product ${index + 1}',
    category: 'electronics',
    image: 'image${index + 1}.jpg',
    rating: Rating(rate: 4.0, count: 50),
  ));

  setUp(() {
    mockFetchAllProducts = MockGetProductsUseCase();
    mockFetchProductDetails = MockGetProductDetailsUseCase();
    mockFetchProductsByCategory = MockGetProductsByCategoryUseCase();
    productCubit = ProductCubit(
      mockFetchAllProducts,
      mockFetchProductDetails,
      mockFetchProductsByCategory,
    );
  });

  tearDown(() {
    productCubit.close();
  });

  group('ProductCubit', () {
    test('initial state is ProductInitial', () {
      expect(productCubit.state, ProductInitial());
    });

    blocTest<ProductCubit, ProductState>(
      'emits [ProductLoading, ProductLoaded] when fetchAllProducts is successful (initial load)',
      build: () {
        when(mockFetchAllProducts(limit: 6, sort: 'asc', skip: 0))
            .thenAnswer((_) async => [tProduct]); // Still use tProduct for simple initial load
        return productCubit;
      },
      act: (cubit) => cubit.fetchAllProducts(isInitialLoad: true),
      expect: () => [
        ProductLoading(),
        ProductLoaded(products: [tProduct], hasMore: false), // hasMore false if fewer than limit
      ],
      verify: (_) {
        verify(mockFetchAllProducts(limit: 6, sort: 'asc', skip: 0)).called(1);
      },
    );
    blocTest<ProductCubit, ProductState>(
      'emits [ProductLoading, ProductError] when fetchAllProducts fails',
      build: () {
        when(mockFetchAllProducts(limit: 6, sort: 'asc', skip: 0))
            .thenThrow(Exception('Failed to fetch'));
        return productCubit;
      },
      act: (cubit) => cubit.fetchAllProducts(isInitialLoad: true),
      expect: () => [
        ProductLoading(),
        const ProductError('Exception: Failed to fetch'),
      ],
    );

    blocTest<ProductCubit, ProductState>(
      'emits [ProductLoading, ProductDetailLoaded] when fetchProductDetails is successful',
      build: () {
        when(mockFetchProductDetails(1)).thenAnswer((_) async => tProduct);
        when(mockFetchProductsByCategory(tProduct.category))
            .thenAnswer((_) async => [tProduct, tProduct2]);
        return productCubit;
      },
      act: (cubit) => cubit.fetchProductDetails(1),
      expect: () => [
        ProductLoading(),
        ProductDetailLoaded(
            product: tProduct, relatedProducts: [tProduct2]),
      ],
      verify: (_) {
        verify(mockFetchProductDetails(1)).called(1);
        verify(mockFetchProductsByCategory(tProduct.category)).called(1);
      },
    );

    blocTest<ProductCubit, ProductState>(
      'emits [ProductLoading, ProductError] when fetchProductDetails fails',
      build: () {
        when(mockFetchProductDetails(1)).thenThrow(Exception('Failed to fetch details'));
        return productCubit;
      },
      act: (cubit) => cubit.fetchProductDetails(1),
      expect: () => [
        ProductLoading(),
        const ProductError('Exception: Failed to fetch details'),
      ],
    );

    // This test now uses blocTest to correctly populate the internal state
    blocTest<ProductCubit, ProductState>(
      'currentProducts getter returns the accumulated list after initial fetch',
      build: () {
        // Use tProductsPage1 to ensure _currentProducts is populated with a full page
        when(mockFetchAllProducts(limit: 6, sort: 'asc', skip: 0))
            .thenAnswer((_) async => tProductsPage1);
        return productCubit;
      },
      act: (cubit) async {
        await cubit.fetchAllProducts(isInitialLoad: true);
      },
      expect: () => [
        ProductLoading(),
        ProductLoaded(products: tProductsPage1, hasMore: true), // Reflects hasMore based on tProductsPage1 length
      ],
      verify: (cubit) {
        // after fetchAllProducts has run, the internal _currentProducts should be populated
        expect(cubit.currentProducts, tProductsPage1);
      },
    );
  });
}
