import 'dart:async';

import 'package:bloc_test/bloc_test.dart';
import 'package:shop_trendy/features/auth/domain/repositories/auth_repository.dart';
import 'package:shop_trendy/features/auth/domain/usecases/login_usecase/sign_in_with_email_password_usecase.dart';
import 'package:shop_trendy/features/auth/domain/usecases/login_usecase/sign_in_with_google_usecase.dart';
import 'package:shop_trendy/features/auth/domain/usecases/sign_out_usecase.dart';
import 'package:shop_trendy/features/auth/domain/usecases/sign_up_usecase/sign_up_with_email_password_usecase.dart';
import 'package:shop_trendy/features/auth/domain/entities/user.dart'
    as app_user;
import 'package:shop_trendy/features/auth/domain/usecases/user_usecase/create_user_usecase.dart';
import 'package:shop_trendy/features/auth/domain/usecases/user_usecase/get_user_by_email_usecase.dart';
import 'package:shop_trendy/features/auth/presentation/cubit/auth_cubit.dart';
import 'package:firebase_auth/firebase_auth.dart' as firebase_auth;
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'auth_cubit_test.mocks.dart'; // Generated by build_runner

// Generate mocks for necessary dependencies
@GenerateMocks([
  SignInWithEmailPasswordUseCase,
  SignUpWithEmailPasswordUseCase,
  SignInWithGoogleUseCase,
  SignOutUseCase,
  AuthRepository,
  GetUserByEmailUseCase,
  CreateUserUseCase,
  firebase_auth.UserCredential,
  firebase_auth.User,
])
void main() {
  late AuthCubit authCubit;
  late MockSignInWithEmailPasswordUseCase mockSignInWithEmailPassword;
  late MockSignUpWithEmailPasswordUseCase mockSignUpWithEmailPassword;
  late MockSignInWithGoogleUseCase mockSignInWithGoogle;
  late MockSignOutUseCase mockSignOut;
  late MockAuthRepository mockAuthRepository;
  late MockGetUserByEmailUseCase mockGetUserByEmail;
  late MockCreateUserUseCase mockCreateUser;
  late MockUser mockFirebaseUser;
  late MockUserCredential mockUserCredential;

  setUp(() {
    mockSignInWithEmailPassword = MockSignInWithEmailPasswordUseCase();
    mockSignUpWithEmailPassword = MockSignUpWithEmailPasswordUseCase();
    mockSignInWithGoogle = MockSignInWithGoogleUseCase();
    mockSignOut = MockSignOutUseCase();
    mockAuthRepository = MockAuthRepository();
    mockGetUserByEmail = MockGetUserByEmailUseCase();
    mockCreateUser = MockCreateUserUseCase();
    mockFirebaseUser = MockUser();
    mockUserCredential = MockUserCredential();

    // Common mock setup for firebaseUser and userCredential
    when(mockUserCredential.user).thenReturn(mockFirebaseUser);
    when(mockFirebaseUser.email).thenReturn('test@example.com');

    // Default stream for authStateChanges (unauthenticated)
    when(mockAuthRepository.authStateChanges).thenAnswer((_) => Stream.empty());

    authCubit = AuthCubit(
      mockSignInWithEmailPassword,
      mockSignUpWithEmailPassword,
      mockSignInWithGoogle,
      mockSignOut,
      mockAuthRepository,
      mockGetUserByEmail,
      mockCreateUser,
    );
  });

  tearDown(() {
    authCubit.close();
  });

  group('AuthCubit', () {
    const String testEmail = 'test@example.com';
    const String testPassword = 'password123';
    final tAppUser = app_user.User(
      id: 1,
      username: 'test',
      email: testEmail,
      password: testPassword,
    );

    test('initial state is AuthInitial', () {
      // With Stream.empty() in setUp, the constructor's listener won't emit immediately.
      expect(authCubit.state, AuthInitial());
    });

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthAuthenticated] when signInWithEmailPassword is successful and user exists in FakeStoreAPI',
      build: () {
        when(
          mockSignInWithEmailPassword(testEmail, testPassword),
        ).thenAnswer((_) async => mockUserCredential);
        when(
          mockGetUserByEmail(testEmail),
        ).thenAnswer((_) async => [tAppUser]); // User exists
        return authCubit;
      },
      act: (cubit) => cubit.signInWithEmailPassword(testEmail, testPassword),
      expect: () => [
        AuthLoading(),
        AuthAuthenticated(user: mockFirebaseUser, appUser: tAppUser),
      ],
      verify: (_) {
        verify(mockSignInWithEmailPassword(testEmail, testPassword)).called(1);
        verify(mockGetUserByEmail(testEmail)).called(1);
        verifyNever(mockCreateUser(any)); // Should not create user
      },
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthAuthenticated] when signInWithEmailPassword is successful and user created in FakeStoreAPI',
      build: () {
        when(
          mockSignInWithEmailPassword(testEmail, testPassword),
        ).thenAnswer((_) async => mockUserCredential);
        when(
          mockGetUserByEmail(testEmail),
        ).thenAnswer((_) async => []); // User does not exist
        when(
          mockCreateUser(any),
        ).thenAnswer((_) async => tAppUser); // User created
        return authCubit;
      },
      act: (cubit) => cubit.signInWithEmailPassword(testEmail, testPassword),
      expect: () => [
        AuthLoading(),
        isA<AuthAuthenticated>(), // Using isA because ID generated randomly
      ],
      verify: (_) {
        verify(mockSignInWithEmailPassword(testEmail, testPassword)).called(1);
        verify(mockGetUserByEmail(testEmail)).called(1);
        verify(mockCreateUser(any)).called(1); // Should create user
      },
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthError] when signInWithEmailPassword fails',
      build: () {
        when(
          mockSignInWithEmailPassword(testEmail, testPassword),
        ).thenThrow(Exception('Login failed'));
        return authCubit;
      },
      act: (cubit) => cubit.signInWithEmailPassword(testEmail, testPassword),
      expect: () => [AuthLoading(), const AuthError('Exception: Login failed')],
      verify: (_) {
        verify(mockSignInWithEmailPassword(testEmail, testPassword)).called(1);
        verifyZeroInteractions(mockGetUserByEmail); // Should not call user API
        verifyZeroInteractions(mockCreateUser);
      },
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthAuthenticated] when signUpWithEmailPassword is successful and user created in FakeStoreAPI',
      build: () {
        when(
          mockSignUpWithEmailPassword(testEmail, testPassword),
        ).thenAnswer((_) async => mockUserCredential);
        when(
          mockGetUserByEmail(testEmail),
        ).thenAnswer((_) async => []); // User does not exist initially
        when(mockCreateUser(any)).thenAnswer((_) async => tAppUser);
        return authCubit;
      },
      act: (cubit) => cubit.signUpWithEmailPassword(testEmail, testPassword),
      expect: () => [AuthLoading(), isA<AuthAuthenticated>()],
      verify: (_) {
        verify(mockSignUpWithEmailPassword(testEmail, testPassword)).called(1);
        verify(mockGetUserByEmail(testEmail)).called(1);
        verify(mockCreateUser(any)).called(1);
      },
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthError] when signUpWithEmailPassword fails',
      build: () {
        when(
          mockSignUpWithEmailPassword(testEmail, testPassword),
        ).thenThrow(Exception('Sign up failed'));
        return authCubit;
      },
      act: (cubit) => cubit.signUpWithEmailPassword(testEmail, testPassword),
      expect: () => [
        AuthLoading(),
        const AuthError('Exception: Sign up failed'),
      ],
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthAuthenticated] when signInWithGoogle is successful and user created in FakeStoreAPI',
      build: () {
        when(
          mockSignInWithGoogle(),
        ).thenAnswer((_) async => mockUserCredential);
        when(
          mockGetUserByEmail(testEmail),
        ).thenAnswer((_) async => []); // User does not exist initially
        when(mockCreateUser(any)).thenAnswer((_) async => tAppUser);
        return authCubit;
      },
      act: (cubit) => cubit.signInWithGoogle(),
      expect: () => [AuthLoading(), isA<AuthAuthenticated>()],
      verify: (_) {
        verify(mockSignInWithGoogle()).called(1);
        verify(mockGetUserByEmail(testEmail)).called(1);
        verify(mockCreateUser(any)).called(1);
      },
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthError] when signInWithGoogle fails',
      build: () {
        when(
          mockSignInWithGoogle(),
        ).thenThrow(Exception('Google Sign In failed'));
        return authCubit;
      },
      act: (cubit) => cubit.signInWithGoogle(),
      expect: () => [
        AuthLoading(),
        const AuthError('Exception: Google Sign In failed'),
      ],
    );

    blocTest<AuthCubit, AuthState>(
      'emits [AuthLoading, AuthError] when signOut fails',
      build: () {
        when(mockSignOut()).thenThrow(Exception('Sign out failed'));
        return authCubit;
      },
      seed: () => AuthAuthenticated(user: mockFirebaseUser, appUser: tAppUser),
      act: (cubit) => cubit.signOut(),
      expect: () => [
        AuthLoading(),
        const AuthError('Exception: Sign out failed'),
      ],
    );
  });
}
